## 第一章习题

<img src="C:\Users\Gavi曦\AppData\Roaming\Typora\typora-user-images\image-20220418114123627.png" alt="image-20220418114123627" style="zoom: 67%;" />

1.

- （1）方便性。操作系统使计算机系统更易于使用
- （2）有效性。 操作系统使资源利用率更高，系统的吞吐量更大。
- （3）可扩充性。 操作系统必须能方便地增加新的功能和模块，并能修改老的功能和模块，以适应计算机硬件、体系结构以及应用发展的要求。
- （4）开放性。操作系统的开发应该遵循世界标准规范，特别是遵循开发系统互连OSI国际标准，从而使其与其他系统之间能彼此兼容、方便地实现互连。

2.

- （1） 操作系统是用户与计算机硬件系统之间的接口。
- （2）操作系统是计算机资源的管理者。
- （3）操作系统实现了对计算机资源的抽象。
- （4）操作系统是计算机工作流程的组织者。它负责在众多作业之间切换切换处理机，并协调它们的推进速度，从而进一步提高系统的性能。

3.操作系统是铺设在裸机（即没有配置任何软件的计算机系统）上的多层软件，它不仅增强了系统的功能，而且还隐藏了对硬件操作的细节，从而实现了对计算机资源的抽象。

4.形成和发展的主要动力：进一步提高资源的利用率和系统的吞吐量。在单处理机环境下，多个作业仅在宏观上同时运行，而在微观上他们是交替执行的。系统中的资源得不到充分的利用。

5.联机IO：在主机的直接控制下进行输入/输出的方式，称为联机输入/输出（On-Line I/O）方式。

脱机IO：脱机输入方式是指在一台外围机的控制下，预先将程序和数据从低速输入设备输入到磁带，当CPU需要这些程序和数据时，再从磁带上高速地读入内存。脱机输出方式是指当CPU需要输出时，先高速地将数据斜土磁带，然后在一台外围机的控制下，通过低速输出设备进行输出。

6.为了满足用户对人——机交互的需求

7.使用户能与自己的作业进行交互，或者说，它追求的主要目标是系统能及时响应用户的终端命令。

（1）作业直接进入内存。

（2）采用轮转运行方式。系统规定每个作业每次只能运行一个时间片，然后就暂停该作业的运行，并立即调度下一个作业运行。如果在不长的时间内能使所有的作业都执行一个时间片的时间，便可以使每个用户都能及时地与自己的作业进行交互，从而可使用户的请求得到及时响应。

8.引入实时操作系统是为了满足应用的需求，更好地满足实时控制领域和实时信息处理领域的需要。

9.硬实时任务是指系统必须满足任务对截止时间的要求，否则可能出现难以预测的后果。用于工业和武器控制的实时系统，通常它所执行的是硬实时任务。

软实时任务也联系着一个截止时间，但并不严格，若偶尔错过了任务的截止时间，对系统产生的影响也不会太大。诸如用于信息查询系统和多媒体系统中的实时系统，通常是软实时任务。

10.

交互性。在信息查询系统中，人与系统的交互性仅限于访问系统中某些特定的专用服务程序。它并不像分时系统那样，能像终端用户提供数据处理、资源共享等服务。而多媒体系统的交互性也仅限于用户发送某些特定的命令，如开始、停止、快进等，由系统立即响应。

及时性。信息查询系统対实时性的要求是依据人所能接受的等待时间确定的，而多媒体系统实时性的要求是，播放出来的音乐和电视能令人满意。实时控制系统的实时性则是以控制对象所要求的截止时间来确定的，一般以秒级到毫秒级。

可靠性。分时系统要求系统可靠，实时系统要求系统高度可靠，因为任何差错都可能带来无法预料的灾难性后果。因此，在实施系统中，往往都采取了多级容错措施来保障系统的安全性及数据的安全性。

11.并发、共享、虚拟和异步。并发

12.一般情况下的共享只是说明某种资源能被大家使用。对于这样的资源共享方式，只要通过合适的安排，用户之间并不会产生对资源的竞争。

而在OS环境下的资源共享或称为资源复用，是指系统中的资源可供内存中多个并发执行的进程共同使用。对于这种资源共享方式，其管理就要复杂得多，因为系统中的资源远少于多道程序需求的总和，会形成它们对共享资源的争夺。所以，系统必须对资源共享进行妥善管理。由于资源属性的不同。进程对资源复用的方式也不同。

互斥共享方式

13.时分复用技术是将不同的信号相互交织在不同的时间段内，沿着同一个信道传输；在接收端再用某种方法，将各个时间段内的信号提取出来还原成原始信号的通信技术。这种技术可以在同一个信道上传输多路信号。

根本原因：利用某设备为一用户服务的空闲时间，又转去为其他用户服务，使设备得到最充分的利用。例如原来的打印机属于临界资源，而通过虚拟设备技术又可以把它变为多台逻辑上的打印机，供多个用户“同时”打印。

14.在多道程序的环境下，每个程序何时执行、何时暂停都是未知的，即它们以不可预知的速度向前推进。

15.

处理机管理主要是对处理机的分配和运行进行管理（对进程的管理）。

处理机的主要功能包括：（1）进程控制。（2）进程同步。（3）进程通信。

（4）进程调度。

16.

内存管理主要是为多到程序的运行提供良好的环境，它的主要功能包括：

（1）内存分配。（2）内存保护。（3）地址映射。（4）内存扩充。

17.

设备管理主要是完成用户的I/O请求，它的主要功能包括：

（1）缓冲管理。（2）设备管理。（3）设备处理。

18.

文件管理主要是使用户能方便、安全地使用各种信息资源，它的主要功能包括：

（1）文件存储空间的管理。（2）目录管理。（3）文件的读/写管理和保护。

19.现代OS除了具备传统OS的基本功能，还具有系统安全，网络的功能和服务，支持多媒体等功能。

20.（1）足够小的内核。（2）基于客户/服务器模式。（3）应用“机制与策略分离”原理。（4）采用面向对象技术

21.（1）提高了系统的可扩展性。（2）增强了系统的可靠性；（3）可移植性强；（4）提供了对分布式系统的支持。（5）融入了面向对象技术。

原因：微内核OS结构是建立在模块化、层次化结构的基础上的，并采用了客户/服务器模式和面向对象的程序设计技术。

22.进程管理，低级存储器管理，中断和陷入处理

23.C/S模式具有独特的优点: (1)数据的分布处理和存储。(2)便于集中管理。(3)灵活性和可扩充性， (4) 易于改编应用软件。

24.面向对象的程序设计技术。

25.微内核的主要思想是，在操作系统内核中只留下一些最基本的功能，而将其他服务尽可能地从内核中分离出去，用若干个运行在用户态下的进程（即服务器进程）来实现，形成所谓的“客户/服务器”模式。

进程管理，低级存储器管理，中断和陷入处理

## 第二章

![image-20220418111215970](C:\Users\Gavi曦\AppData\Roaming\Typora\typora-user-images\image-20220418111215970.png)

1.答：

（1）前趋图是指一个有向无循环图，可记为DAG，它用于描述进程之间执行的先后顺序。
（2）为了更好地描述程序的顺序和并发执行情况。



2.

![image-20220418111854029](C:\Users\Gavi曦\AppData\Roaming\Typora\typora-user-images\image-20220418111854029.png)

3.

程序在并发执行时，由于它们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发执行的程序之间形成了相互制约的关系。相互制约将导致并发程序具有“执行——暂停——执行”这种间断性的活动规律。

4.答：

（1）当系统中存在着多个可以并发执行的程序时，系统中的各种资源将为它们所共享，而这些资源的状态也由这些程序来改变，致使其中任一程序在运行时，其环境都必然会受到其它程序的影响。例如，当处理机已被分配给某个进程时，其它程序必须等待。显然，程序的运行已失去了封闭性。
（2）程序在并发执行时，由于失去了封闭性，也将导致其又失去可再现性。程序经过多次执行后，虽然它们执行时的环境和初始条件相同，但得到结果却各不相同。

5.为了能使程序并发执行，并且可以对并发执行的程序加以描述和控制。

6.答：

（1）动态性：进程的实质是进程实体的执行过程，动态性是进程的最基本特征，进程实体有一定的生命期。程序则只是一组有序指令的集合，并存放于某种介质上，其本身并不具有活动的含义，因而是静态的。
（2）并发性：多个进程实体同存于内存中，且能在一段时间内同时运行。因此，进程能使其进程实体和其它进程实体并发执行。程序因为没有建立PCB是不能参与并发执行的。
（3）独立性：在传统的OS中，独立性是指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡未建立PCB的程序都不能作为一个独立的单位参与运行。

7.答：

（1）作为独立运行基本单位的标志。PCB是进程存在的唯一标志。
（2）能实现间断性运行方式。保存现场CPU信息。
（3）提供进程管理所需要的信息。记录程序和数据的指针信息、资源清单等。
（4）提供进程调度所需要的信息。存储状态信息，调度所需信息。
（5）实现与其它进程的同步与通信。存储信号量等。
（6）当系统创建一个新进程时，就为它建立了一个PCB。进程结束时又回收其PCB，进程于是也随之消亡。系统是通过PCB感知进程的存在的，所以，PCB是进程存在的唯一标志。

8.答：

①程序和数据在内存或外存中的初始指针、资源清单等。
②进程状态信息。

9.答：线性方式、链接方式、索引方式。

10.何谓操作系统内核？内核的主要功能是什么？
答：

（1）将一些与硬件紧密相关的模块（如中断处理程序等）、各种常用设备的驱动程序以及运行频率较高的模块（如时钟管理、进程调度和许多模块所公用的一些基本操作），都安排在紧靠硬件的软件层次中，将它们常驻内存，即通常被称为的OS内核。
（2）支撑功能：中断处理、时钟管理、原语操作。
资源管理功能：进程管理、存储器管理、设备管理。

11.答：

（1）就绪→执行：进程调度。
（2）执行→就绪：时间片完。
（3）执行→阻塞：I/O请求。
（4）阻塞→就绪：I/O完成。

<img src="https://img-blog.csdnimg.cn/9e8e8deb73d94652b3eb846eae4d2ab2.png" alt="img" style="zoom:150%;" />



12.

答：

（1）终端用户的需要、父进程请求、负荷调节的需要、操作系统的需要。
（2）当该操作作用于某个进程时，该进程将被挂起，意味着此时该进程处于静止状态。如果进程正在执行，它将暂停执行。若原本处于就绪状态，则该进程此时暂不接受调度。

13.

答：

①进程当前暂存信息。
②下一指令地址信息。
③进程状态信息。
④过程和系统调用参数及调用地址信息。

14.

答：（1）用户登录：在分时系统中，用户在终端键输入登录命令后，若登录成功，系统将为该用户建立一个进程，并把它插入就绪队列中。
（2）作业调度：在多道批处理系统中，当作业调度程序按一定的算法调度到某个（些）作业时，便将它（们）装入内存，为它（们）创建进程，并把它（们）插入就绪队列中。
（3）提供服务：当运行中的用户程序提出某种请求后，系统将专门创建一个进程来提供用户所需要的服务。
（4）应用请求：由用户进程自己创建新进程，以便使新进程以同创建者进程并发运行的方式完成特定任务。

15.答：（1）正常结束：表示进程的任务已经完成，准备退出运行。
（2）异常结束：是指进程在运行时发生了某种异常事件，使程序无法继续运行。如越界错、保护错、非法指令、特权指令错、运行超时、等待超时、算术运算错、I/O故障。
（3）外界干预：是指进程应外界的请求而终止运行。如操作员或操作系统干预、父进程请求、因父进程终止。

16.答：（1）申请空白PCB，为新进程申请获得唯一的数字标识符，并从PCB集合中索取一个空白PCB。
（2）为新进程分配其运行所需的资源，包括各种物理和逻辑资源，如内存、文件、I/O设备和CPU时间等。
（3）初始化进程控制块（PCB），包括标识信息、处理机状态信息、处理机控制信息。
（4）如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。

17.在撤销一个进程所要完成的主要工作是什么？
答：（1）根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态。
（2）若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度。
（3）若该进程还有子孙进程，还应将其所有子孙进程也都予以终止，以防它们成为不可控的进程。
（4）将被终止进程所拥有的全部资源或者归还给其父进程，或者归还给系统。
（5）将被终止进程（PCB）从所在队列（或链表）中移出，等待其它程序来搜集信息。

18.试说明引起进程阻塞或被唤醒的主要事件是什么？
答：（1）向系统请求共享资源失败：进程在向系统请求共享资源时，由于系统已无足够的资源分配给它，此时进程因不能继续运行而转变为阻塞状态。
（2）等待某种操作的完成。当进程启动某种操作后，如果该进程必须在该操作完成之后才能继续执行，则应先将该进程阻塞起来，以等待操作完成。
（3）新数据尚未到达：对于相互合作的进程，如果一个进程需要先获得另一进程提供的数据后才能对该数据进行处理，只要其所需数据尚未到达，进程便只有阻塞。
（4）等待新任务的到达：在某些系统中，特别是在网络环境下的OS，往往设置一些特定的系统进程，每当这种进程完成任务后便把自己阻塞起来，等待新任务的到来。

19.为什么要在OS中引入线程？
答：为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性。

20.试说明线程具有哪些属性？
答：（1）轻型实体。
（2)独立调度和分派的基本单位。
(3)可并发执行。
(4)共享进程资源。

21.试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较。
答：(1)调度性：在多线程OS中，线程是独立调度的基本单位，进程是资源分配的基本单位。同一进程中切换线程，不会引起进程切换。
(2)并发性：在多线程OS中，进程可以并发执行，线程也可以并发执行，线程的并发大大提高了OS的并发性。
(3)拥有资源：进程拥有资源，而线程（一般）不拥有资源，这样做是为了减少切换线程的开销。同一进程中的多个线程共享该进程的资源。
(4)系统开销：创建和撤销进程，需要分配和回收相关资源，开销较大；切换进程的成本较高，相对而言，创建和切换线程的成本较低，只需要保存少量寄存器内容，开销小。

22.线程控制块TCB包含了哪些内容？
答：(1)线程标识符，为每个线程赋予一个唯一的线程标识符。
(2)一组寄存器，包括程序计数器PC、状态寄存器和通用寄存器的内容。
(3)线程运行状态，用于描述线程正处于何种运行状态。
(4)优先级，描述线程执行的优先程度。
(5)线程专有存储区，用于线程切换时存放现场保护信息，和与该线程相关的统计信息等。
(6)信号屏蔽，即对某些信号加以屏蔽。
(7)堆栈指针，为每个线程设置一个堆栈，用它来保存局部变量以及返回地址。

23.何谓用户级线程和内核支持线程？
答：(1)用户级线程是在用户空间中实现的。对线程的创建、撤销、同步与通信等功能，都无需内核的支持，即用户级线程是与内核无关的。
(2)内核支持线程KST是在内核的支持下运行的，它们的创建、阻塞、撤销和切换等，也都是在内核空间实现的。

24.试说明用户级线程的实现方法。
答：线程管理工作由应用程序完成，内核感受不到用户级线程的存在，在应用程序中通过线程库创建新的线程。

25.试说明内核支持线程的实现方法。
答：线程管理工作由内核完成，由内核的内部需求进行创建和撤销。应用程序可以通过一个内核级线程的编程接口访问内核线程，内核为进程及其内部线程维护上下文信息，需要内核的参与来完成线程的调度。

26.多线程模型有哪几种类型？多对一模型有何优缺点？
答：(1)多对一模型、一对一模型和多对多模型。
(2)点是线程管理的开销小，效率高；缺点是如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞，在任一时刻，只有一个线程能够访问内核，多个线程不能同时在多个处理机上运行。







第三章 处理及调度与死锁
1、高级调度与低级调度的主要任务是什么? 为什么要引入中级调度?
答：高级调度的主要任务：用于决定把外存上处于后背队列中的哪些作业调入内存，并为它们创建进程，分配必要的资源，再将新创建的进程插入就绪队列上，准备执行。低级调度的主要任务：用于决定就绪队列中的哪个进程获得处理机，然后再由分派程序执行将处理机分配给该进程的具体操作。
引入中级调度的主要目的是为了提高系统资源的利用率和系统吞吐量。
2、处理机调度算法的共同目标是什么？批处理系统的调度目标又是什么？
答：共同目标：资源利用率，公平性，平衡性，策略强制执行。批处理系统的调度目标：平均周转时间短，系统吞吐量高，处理机利用率高。
3、何谓作业、作业步和作业流？
答：作业包含通常的程序和数据，还配有作业说明书。系统根据该说明书对程序的运行进行控制。批处理系统中是以作业为基本单位从外存调入内存。
作业步是指每个作业运行期间都必须经过若干个相对独立相互关联的顺序加工的步骤。
作业流是指若干个作业进入系统后依次存放在外存上形成的输入作业流；在操作系统的控制下，逐个作业进程处理，于是形成了处理作业流。
4、在什么情况下需要使用作业控制块JCB?其中包含了哪些内容？
答：每当作业进入系统时，系统便为每个作业建立一个作业控制块JCB，根据作业类型将它插入到相应的后备队列中。
JCB包含的内容通常有：1）作业标识　2）用户名称　3）用户账户　4）作业类型（CPU繁忙型、I/0芳名型、批量型、终端型）　5）作业状态　　6）调度信息（优先级、作业已运行） 7）资源要求　8）进入系统时间　9）、开始处理时间　10）作业完成时间　11）作业退出时间　　12）资源使用情况等
5、在作业调度中应如何确定接纳多少个作业和接纳哪些作业？
答：作业调度每次接纳进入内存的作业数，取决于多道程序度。应将哪些作业从外存调入内存，取决于采用的调度算法。最简单的是先来服务调度算法，较常用的是短作业优先调度算法和基于作业优先级的调度算法。
6、为什么要引入高响应比优先调度算法？它有何优点？
答：高响应比优先调度算法是考虑了作业的等待时间，有考虑了作业运行时间的调度算法，既照顾了短作业，又不致使长作业的等待时间过长，从而改善处理调度的性能。
该算法中的响应比是指作业等待时间与运行比值，响应比公式定义如下:响应比=(等待时间+要求服务时间)/要求服务时间,即RR= (w+s）/s=1+w/s，因此响应比一定是大于1的。短作业与先后次序的兼顾，且不会使长作业长期得不到服务响应比计算系统开销，增加系统开销适用于批处理系统。
7、试说明低级调度的主要功能。
答：（1）保存处理机的现场信息（2）按某种算法选取进程（3）把处理机分配给进程。
8、在抢占调度方式中，抢占的原则是什么？
答：抢占的原则有：时间片原则、优先权原则、短作业优先权原则等。
9、在选择调度方式和调度算法时，应遵循的准则是什么？
答：（1）面向用户的准则：周转时间短、响应时间快、截止时间的保证、优先权准则。
（2）面向系统的准则：系统吞吐量高、处理机利用率好、各类资源的平衡利用。
10、在批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？
答：批处理系统的调度算法：短作业优先、优先权、高响应比优先、多级反馈队列调度算法。
分时系统的调度算法：时间片轮转法。
实时系统的调度算法：最早截止时间优先即EDF、最低松弛度优先即LLF算法。
11、何谓静态和动态优先级？确定静态优先级的依据是什么？
答：静态优先级是指在创建进程时确定且在进程的整个运行期间保持不变的优先级。
　动态优先级是指在创建进程时赋予的优先权，可以随进程推进或随其等待时间增加而改变的优先级，可以获得更好的调度性能。
　确定进程优先级的依据：进程类型、进程对资源的需求和用户要求。
12、试比较FCFS和SJF两种进程调度算法。
答：相同点：两种调度算法都可以用于作业调度和进程调度。
　　 不同点：FCFS调度算法每次都从后备队列中选择一个或多个最先进入该队列的作业，将它们调入内存、分配资源、创建进程、插入到就绪队列。
　　　该算法有利于长作业/进程，不利于短作业/进程。SPF算法每次调度都从后备队列中选择一个或若干个估计运行时间最短的作业，调入内存中运行。该算法有利于短作业/进程，不利于长作业/进程。
13、在时间片轮转法中，应如何确定时间片的大小?
答：时间片应略大于一次典型的交互需要的时间。一般应考虑三个因素：系统对相应时间的要求、就绪队列中进程的数目和系统的处理能力。
14、通过一个例子来说明通常的优先级调度算法不能适用于实时系统？
答：实时系统的调度算法很多，主要是基于任务的开始截止时间和任务紧急/松弛程度的任务优先级调度算法，通常的优先级调度算法不能满足实时系统的调度实时性要求而不适用。
15、为什么说多级反馈队列调度算法能较好地满足各方面用户的需要？
答：终端型用户：由于终端型用户提交的作业多属于交互型作业，通常较小，系统只要能使这些作业在第一队列规定的时间片内完成，便可使终端型用户感到满意
短批处理作业用户：对于这类作业，如果可在第一队列中执行完成，便获得与终端型作业一样的响应时间。对于稍长的短作业，也只需在第二和第三队列各执行一时间片完成，其周转时间仍然较短。
长批处理作业用户：对于长作业，它将依次在第1，2，……n个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理。
16、为什么说传统的几种调度算法都不能算是公平调度算法？
答： 以上介绍的几种调度算法所保证的只是优先运行，如优先级算法是优先级最高的作业优先运行，但并不保证作业占用了多少处理机时间。另外也未考虑到调度的公平性。
17、保证调度算法是如何做到调度的公平性的？
答：保证调度算法是另外一种类型的调度算法，它向用户所做出的保证并不是优先运行，而是明确的性能保证，该算法可以做到调度的公平性。
　　一种比较容易实现的性能保证是处理机分配的公平性。如果在系统中有n个相同类型的进程同时运行，为公平起见，须保证每个进程都获得相同的处理机时间1/n。
18、公平分享调度算法又是如何做到调度的公平性的？
答： 在公平分享调度算法中，调度的公平性主要是针对用户而言，使所有用户能获得相同的处理机时间，或所要求的时间比例。
19、为什么在实时系统中，要求系统（尤其是CPU)有较强的处理能力？
答：在实时系统中，不但包括周期任务、偶发任务、非周期任务，还包括非实时任务。实时任务要求要满足时限，而非实时任务要求要使其响应时间尽可能的短。
多种类型任务的混合，使系统的可调度性分析更加困难。实际上有些实时系统CPU处理能力并不强，比如一些嵌入式实时系统，这就要求系统尽量少做一些并发计算任务，留出足够冗余处理实时任务。
20、按调度方式可将实时调度算法分为哪几种？
答：按调度方式不同，可分为非抢占调度算法和抢占调度算法两种。
21、什么是最早截止时间优先调度算法，请举例说明之。
答：根据任务的开始截止时间确定的任务优先级调度算法。截止时间越早则优先级越高。该算法要求在系统中保持一个实时任务就绪队列，该队列按各任务截止时间的先后排序。
22、什么是最低松弛度优先调度算法，请举例说明之。
答：该算法是根据任务的紧急（或松弛）程度，来确定任务的优先级。任务的紧急程度越高，为该任务所赋予的优先级就越高，以使之优先执行。
例如，一个任务在200ms时必须完成，而它本身所需的运行时间就有100ms，因此，调度程序必须在100ms之前调度执行，该任务的紧急程度（松弛程度）为100ms。
又如，另一任务在400ms时必须完成，它本身需要运行150ms，则其松弛程度为250ms。
最早截止时间优先调度算法：任务要求的截止时间越早，其优先级就越高。
最低松弛度优先调度算法：任务的紧急程度越高，其优先级就越高。
23、何谓“优先级倒置”现象，可采取什么方法来解决？
答：当前0S广泛采用优先级调度算法和抢占方式，然而在系统中存在着影响进程运行的资源而可能产生“优先级倒置”的现象，即高优先级进程（或线程）被低优先级进程（或线程）延迟或阻塞。
24、试分别说明可重用资源和可消耗资源的性质。
答： 可重用性资源：每一个可重用性资源中的单元只能分配给一个进程使用，不允许多个进程共享。进程在使用可重用性资源时，须按照这样的顺序：请求资源、使用资源、释放资源。
　　系统中每一类可重用性资源中的单元数目是相对固定的，进程在运行期间既不能创建也不能删除它。
可消耗性资源：每一类可消耗性资源的单元数目在进程运行期间是可以不断变化的，有时它可以有许多，有时可能为0。进程在运行过程中，可以不断创造可消耗性资源的单元，将它们放入该资源类的缓冲区中，以增加该资源类的单元数目。
　　进程在运行过程中，可以请求若干个可消耗性资源单元，用于进程自己的消耗，不再将它们返回给该资源类中。
25、试举例说明竞争不可抢占资源所引起的死锁。
答：例如，系统中有两个进程P1和P2，它们都准备写两个文件F1和F2，而这两者都属于可重用和不可抢占性资源。进程P1先打开F1，然后再打开文件F2；进程P2先打开文件F2，后打开F1，下面示出了这段代码。
　　P1
　　 P2
　　 …
　　Open(f1,w)；　　　　 Open(f2,w)；
　　Open(f2,w)；　　　　 Open(f1,w)；
　　 两个进程P1和P2在并发执行时，如果P1先打开F1和F2，然后P2才去打开F1（或F2），由于文件F1（F2)已被P1打开，故P2会被阻塞。当P1写完文件F1（或F2）而关闭F1（F2)时，P2会由阻塞状态转为就绪状态，被调度执行后重新打开文件F1（或F2)。
　　在这种情况下，P1和P2都能正常运行下去。若P2先打开F1和F2，然后P1才去打开F1（或F2），P1和P2同样也可以正常运行下去。
但如果在Pl打开F1的同时，P2去打开F2，每个进程都占有一个打开的文件，此时就可能出现问题。因为当P1试图去打开F2，而P2试图去打开F1时，
　　这两个进程都会因文件已被打开而阻塞，它们希望对方关闭自己所需要的文件，但谁也无法运行，因此这两个进程将会无限期地等待下去，而形成死锁。
26.为了破坏“请求和保持”条件而提出了两种协议，试比较这两种协议。
答：第一种协议在所有进程开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源，并且在分配资源时，
　只要有一种资源不能满足进程的要求，即使其它所需的各种资源都空闲也不分配给该进程，而让该进程等待。因此有资源被严重浪费、进程经常会发生饥饿现象等缺点。
　　 第二种协议是对第一种协议的改进，它允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的，
　且已用毕的全部资源，然后再请求新的所需资源。如此便可提高设备的利用率，还可减少进程发生饥饿的概率。
27、何谓死锁?产生死锁的原因和必要条件是什么？
答： (1) 死锁是指多个进程因竞争资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再向前推进；
　（2）产生死锁的原因有二，一是竞争资源，二是进程推进顺序非法；
　（3）必要条件是：互斥条件，请求和保持条件，不剥夺条件和环路等待条件。
28、在解决死锁问题的几个方法中，哪种方法最易于实现？哪种方法是资源利用率最高？
答：解决/处理死锁的方法有预防死锁、避免死锁、检测和解除死锁，其中预防死锁方法最容易实现，但由于所施加的限制条件过于严格，会导致系统资源利用率和系统吞吐量降低；而检测和解除死锁方法可是系统获得较好的资源利用率和系统吞吐量。
29、请详细说明可通过哪些途径预防死锁?
答：(1) 摒弃"请求和保持"条件：系统规定所有进程开始运行之前，都必须一次性地申请其在整个运行过程所需的全部资源，
　　但在分配资源时，只要有一种资源不能满足某进程的要求，即使其它所需的各资源都空闲，也不分配给该进程，而让该进程等待；
　（2）摒弃"不剥夺”条件：系统规定，进程是逐个地提出对资源的要求的。当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满足时，必须释放它已经保持了的所有资源，待以后需要时再重新申请；
　（3）摒弃"环路等待"条件：系统将所有资源按类型进行线性排序，并赋予不同的序号，且所有进程对资源的请求必须严格按序号递增的次序提出，这样，在所形成的资源分配图中，不可能再出现环路，因而摒弃了"环路等待"条件。
30、在教材银行家算法的例子中，如果P0发出的请求向量由Request0（0,2,0）改为Request0（0，1，0），问系统可否将资源分配给它？
答：PO发出请求向量Requst0（0，1,0），按银行家算法进行检查：
①Request0（0,1,0)≤Need0(7,4,3):
②Request0(0,1,0)≤Available(2,3,0)；
③系统暂时先假定可为P0分配资源，修改Available，Allocation1和Need1向量在下面数据结构中的数值：
Available[j]：=Available[j]-Request i[j]；A1location [i,j]：=A1location [i,j]+Request i[j]；eed [i,j]：=Need [i,j]-Requesti[j]；
计算结果为：
Available0=Available0(2,3,0)-Request0(0,1,0)=(2,2,0)
Allocation0=Allocation0(0,1,0)+Request0 (0,1,0)=(0,2,0)
Need0=Need0(7,4,3)-Request0(0,1,0)=(7,3,3)


可以找到一个安全序列（P1，P3，P4，P2，P0}，所以系统是安全的，系统可以立即将P1所申请的资源（0，1，0）分配给它。给P1分配资源之后，系统的资源数目Available=(2，2，0）
31、在银行家算法中，若出现下述资源分配情况，请问：

